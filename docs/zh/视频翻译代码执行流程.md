# 视频翻译代码执行流程

> 用户点击"开始翻译"按钮后的完整代码执行路径

## 📋 目录

1. [前端交互流程](#前端交互流程)
2. [后端API处理](#后端api处理)
3. [核心业务流程](#核心业务流程)
4. [详细执行步骤](#详细执行步骤)
5. [关键函数说明](#关键函数说明)

---

## 🖱️ 前端交互流程

### 1. 用户点击按钮

**文件位置：** `static/index.html:886`

```html
<!-- 执行按钮 -->
<button type="button" id="executeButton" class="btn-primary">
  开始翻译 Start Translating
</button>
```

### 2. 按钮点击事件处理

**文件位置：** `static/index.html:2389`

```javascript
executeButton.addEventListener("click", async () => {
  console.log("开始任务按钮被点击");
  
  // 1. 更新状态栏
  statusBar.textContent = "正在执行任务... - " + getSimpleTime();
  
  // 2. 验证参数
  if (bilingualToggle && !bilingualToggle.checked && 
      embedSubtitleVideoTypeToggle && embedSubtitleVideoTypeToggle.checked) {
    alert("合成字幕嵌入视频必须打开双语选项");
    return;
  }
  
  // 3. 检查视频URL
  const inputType = document.querySelector('input[name="inputType"]:checked');
  if (!inputType) {
    alert("请选择输入方式");
    return;
  }
  
  // 4. 收集表单参数
  const params = getParams();
  
  // 5. 调用启动任务API
  const taskId = await startTask({ ...params, url });
  
  // 6. 开始轮询任务进度
  if (taskId) {
    executeButton.disabled = true;
    progressSection.classList.remove("hidden");
    await pollTaskProgress(taskId);
  }
});
```

### 3. 收集表单参数

**文件位置：** `static/index.html:2042`

```javascript
function getParams() {
  return {
    language: "zh_cn",
    origin_lang: document.getElementById("source-language").value,
    target_lang: translationToggle.checked ? translationLanguage.value : "none",
    bilingual: bilingualToggle.checked ? 1 : 2,
    translation_subtitle_pos: bilingualPosition.value === "top" ? 1 : 2,
    tts: voiceoverToggle.checked ? 1 : 2,
    modal_filter: document.getElementById("filler-filter-toggle").checked ? 1 : 2,
    embed_subtitle_video_type: embedSubtitleVideoTypeToggle.checked ? 
      embedSubtitle.value : "none",
    // ... 更多参数
  };
}
```

### 4. 调用启动任务API

**文件位置：** `static/index.html:2209`

```javascript
async function startTask(params) {
  const response = await fetch(API_SUBMIT_URL, {  // "/api/capability/subtitleTask"
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(params),
  });
  
  const data = await response.json();
  if (+data.error !== 0 && +data.error !== 200) {
    throw new Error(data.msg || "启动任务失败");
  }
  
  return data.data.task_id;
}
```

### 5. 轮询任务进度

**文件位置：** `static/index.html:2229`

```javascript
async function pollTaskProgress(taskId) {
  const interval = setInterval(async () => {
    const response = await fetch(`/api/capability/subtitleTask?taskId=${taskId}`);
    const data = await response.json();
    
    // 更新进度条
    progressBar.value = data.data.process_percent;
    
    // 检查任务状态
    if (data.data.status === 2) {  // 完成
      clearInterval(interval);
      showDownloadLinks(taskId);
    } else if (data.data.status === 3) {  // 失败
      clearInterval(interval);
      alert("任务失败: " + data.msg);
    }
  }, 5000);  // 每5秒轮询一次
}
```

---

## 🔌 后端API处理

### 1. 路由注册

**文件位置：** `internal/server/server.go`

```go
func StartBackend() error {
    r := gin.Default()
    
    // 注册路由
    r.POST("/api/capability/subtitleTask", handler.StartSubtitleTask)
    r.GET("/api/capability/subtitleTask", handler.GetSubtitleTask)
    
    // 启动服务器
    r.Run(fmt.Sprintf("%s:%d", config.Conf.Server.Host, config.Conf.Server.Port))
}
```

### 2. Handler层：接收请求

**文件位置：** `internal/handler/subtitle_task.go:16`

```go
func (h Handler) StartSubtitleTask(c *gin.Context) {
    // 1. 解析请求参数
    var req dto.StartVideoSubtitleTaskReq
    if err := c.ShouldBindJSON(&req); err != nil {
        log.GetLogger().Error("StartSubtitleTask ShouldBindJSON err", zap.Error(err))
        response.R(c, response.Response{
            Error: -1,
            Msg:   "参数错误",
        })
        return
    }
    
    // 2. 检查配置是否需要重新初始化
    if configUpdated {
        log.GetLogger().Info("检测到配置更新，重新初始化服务")
        deps.CheckDependency()
        h.Service = service.NewService()
        configUpdated = false
    }
    
    // 3. 调用Service层处理业务逻辑
    data, err := h.Service.StartSubtitleTask(req)
    if err != nil {
        response.R(c, response.Response{
            Error: -1,
            Msg:   err.Error(),
        })
        return
    }
    
    // 4. 返回成功响应
    response.R(c, response.Response{
        Error: 0,
        Msg:   "成功",
        Data:  data,  // 包含 task_id
    })
}
```

---

## ⚙️ 核心业务流程

### Service层：任务编排

**文件位置：** `internal/service/subtitle_service.go:20`

```go
func (s Service) StartSubtitleTask(req dto.StartVideoSubtitleTaskReq) (*dto.StartVideoSubtitleTaskResData, error) {
    // 1. 校验链接
    if strings.Contains(req.Url, "youtube.com") {
        videoId, _ := util.GetYouTubeID(req.Url)
        if videoId == "" {
            return nil, fmt.Errorf("链接不合法")
        }
    }
    
    // 2. 生成任务ID
    taskId := fmt.Sprintf("%s_%s", 
        util.SanitizePathName(videoName), 
        util.GenerateRandStringWithUpperLowerNum(4))
    
    // 3. 创建任务文件夹
    taskBasePath := filepath.Join("./tasks", taskId)
    os.MkdirAll(filepath.Join(taskBasePath, "output"), os.ModePerm)
    
    // 4. 创建任务对象
    taskPtr := &types.SubtitleTask{
        TaskId:   taskId,
        VideoSrc: req.Url,
        Status:   types.SubtitleTaskStatusProcessing,
    }
    storage.SubtitleTasks.Store(taskId, taskPtr)
    
    // 5. 构造任务参数
    stepParam := types.SubtitleTaskStepParam{
        TaskId:                  taskId,
        TaskPtr:                 taskPtr,
        TaskBasePath:            taskBasePath,
        Link:                    req.Url,
        SubtitleResultType:      resultType,
        EnableModalFilter:       req.ModalFilter == types.SubtitleTaskModalFilterYes,
        EnableTts:               req.Tts == types.SubtitleTaskTtsYes,
        OriginLanguage:          types.StandardLanguageCode(req.OriginLanguage),
        TargetLanguage:          types.StandardLanguageCode(req.TargetLang),
        EmbedSubtitleVideoType:  req.EmbedSubtitleVideoType,
        // ... 更多参数
    }
    
    // 6. 启动异步任务
    go func() {
        defer func() {
            if r := recover(); r != nil {
                log.GetLogger().Error("autoVideoSubtitle panic", zap.Any("panic:", r))
                stepParam.TaskPtr.Status = types.SubtitleTaskStatusFailed
            }
        }()
        
        // 执行完整流程
        s.linkToFile(ctx, &stepParam)        // 下载/提取音频
        s.audioToSubtitle(ctx, &stepParam)   // 音频转字幕
        s.srtFileToSpeech(ctx, &stepParam)   // 字幕转语音
        s.embedSubtitles(ctx, &stepParam)    // 嵌入字幕
        s.uploadSubtitles(ctx, &stepParam)   // 上传结果
    }()
    
    // 7. 立即返回任务ID
    return &dto.StartVideoSubtitleTaskResData{
        TaskId: taskId,
    }, nil
}
```

---

## 📝 详细执行步骤

### 步骤1：链接转文件 (linkToFile)

**文件位置：** `internal/service/link2file.go:18`

**日志时间：** 10:37:53 - 10:38:19 (约26秒)

```go
func (s Service) linkToFile(ctx context.Context, stepParam *types.SubtitleTaskStepParam) error {
    link := stepParam.Link
    audioPath := fmt.Sprintf("%s/%s", stepParam.TaskBasePath, types.SubtitleTaskAudioFileName)
    videoPath := fmt.Sprintf("%s/%s", stepParam.TaskBasePath, types.SubtitleTaskVideoFileName)
    
    stepParam.TaskPtr.ProcessPct = 3  // 更新进度：3%
    
    if strings.Contains(link, "local:") {
        // 本地文件：使用ffmpeg提取音频
        videoPath = strings.ReplaceAll(link, "local:", "")
        cmd := exec.Command(storage.FfmpegPath, 
            "-i", videoPath,           // 输入视频
            "-vn",                     // 不处理视频流
            "-ar", "44100",            // 采样率
            "-ac", "2",                // 声道数
            "-ab", "192k",             // 比特率
            "-f", "mp3",               // 输出格式
            audioPath)                 // 输出文件
        output, err := cmd.CombinedOutput()
        
    } else if strings.Contains(link, "youtube.com") {
        // YouTube：使用yt-dlp下载音频
        cmdArgs := []string{
            "-f", "bestaudio[ext=m4a]/bestaudio[ext=mp3]/bestaudio/worst",
            "--extract-audio",
            "--audio-format", "mp3",
            "--audio-quality", "192K",
            "-o", audioPath,
            stepParam.Link,
        }
        cmd := exec.Command(storage.YtdlpPath, cmdArgs...)
        output, err := cmd.CombinedOutput()
        
    } else if strings.Contains(link, "bilibili.com") {
        // B站：使用yt-dlp下载音频
        cmdArgs := []string{
            "-f", "bestaudio[ext=m4a]",
            "-x",
            "--audio-format", "mp3",
            "-o", audioPath,
            stepParam.Link,
        }
        cmd := exec.Command(storage.YtdlpPath, cmdArgs...)
        output, err := cmd.CombinedOutput()
    }
    
    stepParam.TaskPtr.ProcessPct = 6  // 更新进度：6%
    stepParam.AudioFilePath = audioPath
    
    // 如果需要嵌入字幕，下载原视频
    if !strings.HasPrefix(link, "local:") && stepParam.EmbedSubtitleVideoType != "none" {
        cmdArgs := []string{
            "-f", "bestvideo[height<=1080][ext=mp4]+bestaudio[ext=m4a]",
            "-o", videoPath,
            stepParam.Link,
        }
        cmd := exec.Command(storage.YtdlpPath, cmdArgs...)
        cmd.CombinedOutput()
    }
    
    stepParam.InputVideoPath = videoPath
    stepParam.TaskPtr.ProcessPct = 10  // 更新进度：10%
    
    return nil
}
```

**日志输出：**
```
2025-10-06T10:37:53.244+0800  info  service/subtitle_service.go:137  video subtitle start task
```

### 步骤2：音频转字幕 (audioToSubtitle)

**文件位置：** `internal/service/audio2subtitle.go:31`

**日志时间：** 10:38:19 - 10:41:15 (约3分钟)

```go
func (s Service) audioToSubtitle(ctx context.Context, stepParam *types.SubtitleTaskStepParam) error {
    // 2.1 音频转SRT
    err := s.audioToSrt(ctx, stepParam)
    if err != nil {
        return fmt.Errorf("audioToSubtitle audioToSrt error: %w", err)
    }
    
    // 2.2 分割SRT
    err = splitSrt(stepParam)
    if err != nil {
        return fmt.Errorf("audioToSubtitle splitSrt error: %w", err)
    }
    
    stepParam.TaskPtr.ProcessPct = 95  // 更新进度：95%
    return nil
}
```

#### 2.1 音频转SRT (audioToSrt)

**文件位置：** `internal/service/audio2subtitle.go:233`

```go
func (s Service) audioToSrt(ctx context.Context, stepParam *types.SubtitleTaskStepParam) error {
    log.GetLogger().Info("audioToSubtitle.audioToSrt start", zap.Any("taskId", stepParam.TaskId))
    
    // 2.1.1 计算音频分割点
    timePoints, err := GetSplitPoints(
        stepParam.AudioFilePath, 
        float64(config.Conf.App.SegmentDuration)*60)
    
    log.GetLogger().Info("audioToSubtitle audioToSrt GetSplitPoints completed", 
        zap.Any("timePoints", timePoints))
    // 输出: [0, 298.7, 596.0, 903.1, 1204.0, 1499.6, 1796.8, 1926.6]
    
    stepParam.TaskPtr.ProcessPct = 15  // 更新进度：15%
    
    segmentNum := len(timePoints) - 1  // 7个分段
    
    // 创建处理队列
    pendingSplitQueue := make(chan DataWithId[[2]float64], segmentNum)
    splitResultQueue := make(chan DataWithId[string], segmentNum)
    pendingTranscriptionQueue := make(chan DataWithId[string], segmentNum)
    transcribedQueue := make(chan DataWithId[*types.TranscriptionData], segmentNum)
    pendingTranslationQueue := make(chan DataWithId[string], segmentNum)
    translatedQueue := make(chan DataWithId[[]*TranslatedItem], segmentNum)
    
    eg, ctx := errgroup.WithContext(ctx)
    
    // 2.1.2 并发分割音频
    for range runtime.NumCPU() {
        eg.Go(func() error {
            for splitItem := range pendingSplitQueue {
                log.GetLogger().Info("Begin split audio", 
                    zap.Any("splitId", splitItem.Id))
                
                outputFileName := filepath.Join(stepParam.TaskBasePath, 
                    fmt.Sprintf("split_%d.mp3", splitItem.Id))
                
                err := ClipAudio(stepParam.AudioFilePath, outputFileName, 
                    splitItem.Data[0], splitItem.Data[1])
                
                log.GetLogger().Info("Split audio completed", 
                    zap.Any("splitId", splitItem.Id))
                
                splitResultQueue <- DataWithId[string]{
                    Data: outputFileName,
                    Id:   splitItem.Id,
                }
            }
            return nil
        })
    }
    
    // 2.1.3 并发语音识别
    for range config.Conf.App.TranscribeParallelNum {  // 默认2个并发
        eg.Go(func() error {
            for audioFileItem := range pendingTranscriptionQueue {
                log.GetLogger().Info("Begin transcribe", 
                    zap.Any("splitId", audioFileItem.Id))
                
                // 调用OpenAI Whisper API
                transcriptionData, err := s.transcribeAudio(
                    audioFileItem.Id, 
                    audioFileItem.Data, 
                    string(stepParam.OriginLanguage), 
                    stepParam.TaskBasePath)
                
                log.GetLogger().Info("Transcribe completed", 
                    zap.Any("splitId", audioFileItem.Id))
                
                transcribedQueue <- DataWithId[*types.TranscriptionData]{
                    Data: transcriptionData,
                    Id:   audioFileItem.Id,
                }
            }
            return nil
        })
    }
    
    // 2.1.4 翻译处理
    eg.Go(func() error {
        for translateItem := range pendingTranslationQueue {
            log.GetLogger().Info("Begin to translate", 
                zap.Any("splitId", translateItem.Id))
            
            // 分句+翻译
            translatedResults, err := s.splitTextAndTranslateV2(
                stepParam.TaskBasePath, 
                translateItem.Data, 
                stepParam.OriginLanguage, 
                stepParam.TargetLanguage, 
                stepParam.EnableModalFilter, 
                translateItem.Id)
            
            log.GetLogger().Info("Translate completed", 
                zap.Any("splitId", translateItem.Id))
            
            // 二次分割长句
            splitResults, err := s.splitTranslateItem(translatedResults)
            if err != nil {
                log.GetLogger().Error("audioToSubtitle audioToSrt splitTranslateItem err", 
                    zap.Error(err))
                // 不中断，使用原结果
                translatedQueue <- DataWithId[[]*TranslatedItem]{
                    Data: translatedResults,
                    Id:   translateItem.Id,
                }
            } else {
                translatedQueue <- DataWithId[[]*TranslatedItem]{
                    Data: splitResults,
                    Id:   translateItem.Id,
                }
            }
        }
        return nil
    })
    
    // 等待所有任务完成
    eg.Wait()
    
    stepParam.TaskPtr.ProcessPct = 90  // 更新进度：90%
    
    log.GetLogger().Info("audioToSubtitle.audioToSrt end", 
        zap.Any("taskId", stepParam.TaskId))
    
    return nil
}
```

**日志输出：**
```
2025-10-06T10:38:19.808+0800  info  service/audio2subtitle.go:241  audioToSubtitle.audioToSrt start
2025-10-06T10:38:20.396+0800  info  service/audio2subtitle.go:247  audioToSubtitle audioToSrt GetSplitPoints completed
  {"timePoints": [0, 298.709, 595.995, 903.051, 1203.958, 1499.556, 1796.777, 1926.583]}
2025-10-06T10:38:20.396+0800  info  service/audio2subtitle.go:303  Begin split audio  {"splitId": 0}
2025-10-06T10:38:22.000+0800  info  service/audio2subtitle.go:310  Split audio completed  {"splitId": 6}
2025-10-06T10:38:22.000+0800  info  service/audio2subtitle.go:337  Begin transcribe  {"splitId": 6}
2025-10-06T10:38:36.888+0800  info  service/audio2subtitle.go:348  Transcribe completed  {"splitId": 6}
2025-10-06T10:38:36.889+0800  info  service/audio2subtitle.go:373  Begin to translate  {"splitId": 6}
2025-10-06T10:38:59.415+0800  info  service/audio2subtitle.go:384  Translate completed  {"splitId": 6}
```

### 步骤3：字幕转语音 (srtFileToSpeech)

**文件位置：** `internal/service/srt2speech.go`

**日志时间：** 10:41:15 (如果启用TTS)

```go
func (s Service) srtFileToSpeech(ctx context.Context, stepParam *types.SubtitleTaskStepParam) error {
    if !stepParam.EnableTts {
        log.GetLogger().Info("srtFileToSpeech skip", zap.String("task id", stepParam.TaskId))
        return nil
    }
    
    // 读取字幕文件
    srtFile := filepath.Join(stepParam.TaskBasePath, "target_language_srt.srt")
    subtitles, err := parseSRT(srtFile)
    
    // 为每个字幕生成语音
    for i, subtitle := range subtitles {
        audioFile := filepath.Join(stepParam.TaskBasePath, fmt.Sprintf("tts_%d.wav", i))
        err := s.TtsClient.Text2Speech(subtitle.Text, stepParam.TtsVoiceCode, audioFile)
    }
    
    // 合并所有语音文件
    finalOutput := filepath.Join(stepParam.TaskBasePath, "tts_final.wav")
    err = concatenateAudioFiles(audioFiles, finalOutput, stepParam.TaskBasePath)
    
    // 替换视频中的音频
    videoWithTtsPath := filepath.Join(stepParam.TaskBasePath, "video_with_tts.mp4")
    err = util.ReplaceAudioInVideo(stepParam.InputVideoPath, finalOutput, videoWithTtsPath)
    
    stepParam.TaskPtr.ProcessPct = 98  // 更新进度：98%
    return nil
}
```

### 步骤4：嵌入字幕 (embedSubtitles)

**文件位置：** `internal/service/srt_embed.go:24`

**日志时间：** 10:41:15 - 10:42:09 (约54秒)

```go
func (s Service) embedSubtitles(ctx context.Context, stepParam *types.SubtitleTaskStepParam) error {
    if stepParam.EmbedSubtitleVideoType == "none" {
        log.GetLogger().Info("合成视频：不合成")
        return nil
    }
    
    // 获取视频分辨率
    width, height, err := getResolution(stepParam.InputVideoPath)
    
    // 横屏视频
    if stepParam.EmbedSubtitleVideoType == "horizontal" || stepParam.EmbedSubtitleVideoType == "all" {
        if width < height {
            log.GetLogger().Info("检测到输入视频是竖屏，无法合成横屏视频，跳过")
            return nil
        }
        
        log.GetLogger().Info("合成视频：横屏")
        err = embedSubtitles(stepParam, true, stepParam.EnableTts)
    }
    
    // 竖屏视频
    if stepParam.EmbedSubtitleVideoType == "vertical" || stepParam.EmbedSubtitleVideoType == "all" {
        if width > height {
            // 转换为竖屏
            transferredVerticalVideoPath := filepath.Join(stepParam.TaskBasePath, 
                "transferred_vertical.mp4")
            err = convertToVertical(stepParam.InputVideoPath, transferredVerticalVideoPath, 
                stepParam.VerticalVideoMajorTitle, stepParam.VerticalVideoMinorTitle)
            stepParam.InputVideoPath = transferredVerticalVideoPath
        }
        
        log.GetLogger().Info("合成视频：竖屏")
        err = embedSubtitles(stepParam, false, stepParam.EnableTts)
    }
    
    log.GetLogger().Info("字幕嵌入视频成功")
    return nil
}
```

**日志输出：**
```
2025-10-06T10:41:15.480+0800  info  service/srt_embed.go:40  合成视频：横屏
2025-10-06T10:42:09.851+0800  info  service/srt_embed.go:65  字幕嵌入视频成功
```

### 步骤5：上传字幕 (uploadSubtitles)

**文件位置：** `internal/service/upload_subtitle.go`

```go
func (s Service) uploadSubtitles(ctx context.Context, stepParam *types.SubtitleTaskStepParam) error {
    // 将生成的字幕文件移动到output目录
    // 更新任务状态为完成
    stepParam.TaskPtr.Status = types.SubtitleTaskStatusCompleted
    stepParam.TaskPtr.ProcessPct = 100
    
    log.GetLogger().Info("video subtitle task end", zap.String("taskId", stepParam.TaskId))
    return nil
}
```

**日志输出：**
```
2025-10-06T10:42:09.851+0800  info  service/subtitle_service.go:182  video subtitle task end
```

---

## 🔑 关键函数说明

### 1. GetSplitPoints - 计算音频分割点

**文件位置：** `internal/service/split_audio.go:106`

**作用：** 根据音频时长和配置的分段时长，计算最佳分割点（在静音处分割）

```go
func GetSplitPoints(input string, segmentDuration float64) ([]float64, error) {
    // 获取音频总时长
    audioDuration, err := util.GetAudioDuration(input)
    
    // 计算分段数量
    segmentNum := int(math.Ceil(audioDuration / segmentDuration))
    
    // 初始化分割点
    timePoints := make([]float64, segmentNum+1)
    for i := range segmentNum {
        timePoints[i] = float64(i) * segmentDuration
    }
    
    // 并发查找每个分割点附近的最安静时刻
    eg := errgroup.Group{}
    for i := 1; i < segmentNum; i++ {
        eg.Go(func() error {
            start := timePoints[i] - TOLERANCE_DURATION  // 前后8秒容差
            end := timePoints[i] + TOLERANCE_DURATION
            timePoint, err := getQuietestTimePoint(input, start, end)
            timePoints[i] = timePoint
            return nil
        })
    }
    
    eg.Wait()
    timePoints[len(timePoints)-1] = audioDuration
    
    return timePoints, nil
}
```

### 2. transcribeAudio - 语音识别

**文件位置：** `internal/service/audio2subtitle.go:92`

```go
func (s Service) transcribeAudio(id int, audioFilePath string, language string, taskBasePath string) (*types.TranscriptionData, error) {
    // 调用转录服务（OpenAI Whisper）
    transcriptionData, err := s.Transcriber.Transcription(
        audioFilePath, 
        language, 
        taskBasePath)
    
    return transcriptionData, err
}
```

### 3. splitTextAndTranslateV2 - 分句并翻译

**文件位置：** `internal/service/audio2subtitle.go`

```go
func (s Service) splitTextAndTranslateV2(taskBasePath, text string, originLang, targetLang types.StandardLanguageCode, enableModalFilter bool, splitId int) ([]*TranslatedItem, error) {
    // 1. 使用LLM分割长句
    sentences, err := s.splitOriginLongSentence(text, originLang)
    
    // 2. 过滤语气词（如果启用）
    if enableModalFilter {
        sentences = filterModalWords(sentences)
    }
    
    // 3. 并发翻译每个句子
    results := make([]*TranslatedItem, len(sentences))
    eg := errgroup.Group{}
    
    for i, sentence := range sentences {
        eg.Go(func() error {
            translation, err := s.ChatCompleter.ChatCompletion(
                fmt.Sprintf("Translate to %s: %s", targetLang, sentence))
            results[i] = &TranslatedItem{
                OriginText:     sentence,
                TranslatedText: translation,
            }
            return nil
        })
    }
    
    eg.Wait()
    return results, nil
}
```

### 4. splitTranslateItem - 二次分割长句

**文件位置：** `internal/service/audio2subtitle.go:1256`

```go
func (s Service) splitTranslateItem(items []*TranslatedItem) ([]*TranslatedItem, error) {
    results := []*TranslatedItem{}
    
    for _, item := range items {
        // 检查翻译后的文本是否过长
        if len(item.TranslatedText) > config.Conf.App.MaxSentenceLength {
            log.GetLogger().Info("splitTranslateItem long sentence detected", 
                zap.String("text", item.TranslatedText))
            
            // 使用LLM再次分割
            splitResults, err := s.splitLongSentence(item)
            if err != nil {
                log.GetLogger().Error("splitTranslateItem splitLongSentence error", 
                    zap.Error(err))
                // 失败时使用原句
                results = append(results, item)
            } else {
                results = append(results, splitResults...)
            }
        } else {
            results = append(results, item)
        }
    }
    
    return results, nil
}
```

---

## 📊 完整流程图

```
用户点击"开始翻译"
    ↓
前端收集参数
    ↓
POST /api/capability/subtitleTask
    ↓
Handler.StartSubtitleTask
    ↓
Service.StartSubtitleTask
    ├─ 生成任务ID
    ├─ 创建任务对象
    └─ 启动异步Goroutine
        ↓
    linkToFile (10%)
        ├─ 本地文件：ffmpeg提取音频
        ├─ YouTube：yt-dlp下载
        └─ B站：yt-dlp下载
        ↓
    audioToSubtitle (10% → 95%)
        ├─ audioToSrt
        │   ├─ GetSplitPoints (15%)
        │   │   └─ 计算7个分割点
        │   ├─ 并发分割音频 (15% → 20%)
        │   │   └─ ClipAudio × 7
        │   ├─ 并发语音识别 (20% → 50%)
        │   │   └─ Whisper API × 7
        │   └─ 并发翻译 (50% → 90%)
        │       ├─ splitTextAndTranslateV2 × 7
        │       └─ splitTranslateItem × 7
        └─ splitSrt (90% → 95%)
        ↓
    srtFileToSpeech (95% → 98%)
        ├─ 生成TTS音频
        └─ 替换视频音轨
        ↓
    embedSubtitles (98% → 99%)
        ├─ 横屏视频合成
        └─ 竖屏视频合成
        ↓
    uploadSubtitles (99% → 100%)
        └─ 移动文件到output目录
        ↓
    任务完成
```

---

## 🎯 总结

### 关键技术点

1. **异步处理** - 使用Goroutine异步执行任务，立即返回任务ID
2. **并发优化** - 使用errgroup并发处理音频分割、识别、翻译
3. **进度更新** - 通过`TaskPtr.ProcessPct`实时更新任务进度
4. **错误恢复** - 使用defer+recover捕获panic，防止任务崩溃
5. **重试机制** - 关键步骤（识别、翻译）支持多次重试
6. **降级策略** - 长句分割失败时使用原句，不中断流程

### 性能数据（基于日志）

| 阶段 | 耗时 | 占比 |
|------|------|------|
| 音频提取 | ~26秒 | 9.6% |
| 音频分割 | ~3.5秒 | 1.3% |
| 语音识别 | ~2分5秒 | 46.5% |
| 翻译处理 | ~2分39秒 | 59.1% |
| 视频合成 | ~54秒 | 20.1% |
| **总计** | **~4分30秒** | **100%** |

### 优化建议

1. **缓存机制** - 缓存LLM翻译结果，避免重复调用
2. **批量处理** - 合并多个短句一起翻译，减少API调用次数
3. **预处理** - 提前检测视频时长，动态调整分段策略
4. **并发控制** - 根据API限流动态调整并发数

